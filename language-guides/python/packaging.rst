=========================
Packaging Python Projects
=========================

.. seealso::

    `The PyPA documentation on distributions
    <https://packaging.python.org/en/latest/distributing/#configuring-your-project>`_

.. glossary::
    module
        1) used loosely to mean `source file`
        2) A runtime object, often an instance of `types.ModuleType`,
           and often corresponding to a source file on disk (but not
           necessarily so, runtime modules can be instances of any objects)

    source file
        A file containing Python statements. The typical source file
        extension is ``.py``.

    script
        A source file specifically intended to be executed rather than
        imported or used as library code. Scripts do *not* necessarily
        have file extensions.

            .. seealso::

                `scripts-and-binaries`_

    package
        A directory containing a :file:`__init__.py` along with
        typically other source files, subpackages, and package data
        (non-Python files)

    repository root
        The root of a version-controlled repository.

        It should contain at minimum:
            * a README
            * one (or more) packages
            * a :term:`setup.py`

        And may also contain:
            * a :term:`requirements file`
            * a :doc:`deployment </deployment>` script
            * a `MANIFEST.in
              <https://packaging.python.org/en/latest/distributing/?highlight=manifest#manifest-in>`_
              containing additional package
              data to include when building distributions of the package
            * development-focused provisioning of a virtual machine or other
              locally-runnable, fully integrated deployment of the package
              along with any needed databases or hard dependencies


Package Structure
=================

For packaging Python projects (new and old), follow the guidelines outlined in
`this blog post
<http://blog.habnab.it/blog/2013/07/21/python-packages-and-you/>`_ with only
slight modification and addition:

* Always use `setuptools` when writing a `setup.py` (mentioned in the
  article as a suitable alternative, but setuptools is now more mature and
  better maintained than it was).
* Avoid ``if __name__ == "__main__"`` blocks in modules in favor of an explicit
  script or a setuptools `entry point
  <https://pythonhosted.org/setuptools/setuptools.html#automatic-script-creation>`_.


.. _requirements.txt:


requirements.txt
================

:file:`requirements.txt` (and other similarly named files) are mechanisms for
specifying *deployment environments* -- i.e., they delineate a *fixed* or
"almost" fixed set of package versions that are known-working for the
associated package.

A requirements file should be *generated by hand* as a package grows
dependencies and is deployed, by adding each dependency to the requirements
file along with the version used at time of deployment.

.. note::

    Avoid using :command:`pip freeze` post hoc to generate requirements files.

Installing a requirements file is essentially equivalent to passing each of its
containing options as command line options to `pip`, and can be performed by
running:

    $ pip install -r requirements.txt

.. seealso::

    https://caremad.io/2013/07/setup-vs-requirement/

Common variants of requirements are :file:`test-requirements.txt` to specify
testing dependencies, :file:`doc-requirements.txt` to specify requirements for
building a package's documentation, and :file:`deploy-requirements.txt` for
specifying deployment dependencies. These variants should generally contain a
line with ``-r requirements.txt`` if they need to also include the general
requirements, rather than duplicating them.

.. note::

    In all cases, requirements contain *Python* (and closely related)
    dependencies. A package may have non-Python dependencies that may
    not be installable via :command:`pip install` and may require the
    use of the host OS's package manger.


.. _versioning:


Versioning
================

For automated versioning the recommended package is `vcversioner <https://pypi.python.org/pypi/vcversioner/>`.

Basically, the software will use the system's version control in order to manage versioning.  


Using the `Exchanges <https://github.com/Magnetic/Exchanges>` repo as an example, the following changes are required in order to use vcversioner.

* Add vcversioner to :file:`setup.py` required packages list and as a hook with key pointing to version file
  .. code-block:: python

        setup(
            name="exchanges",
            setup_requires=["vcversioner"],
            ... 
            vcversioner={"version_module_paths": ["exchanges/_version.py"]},
        )


* Alter :file:`__init__.py` file in the projects source code package e.g. :file:`Exchanges/exchanges` where :file:`Exchanges` is repo root as defined in the top of this file. 
  .. code-block:: python
  
  from exchanges._version import __version__
  

* initialize a first version manually. E.g. In git repo run something like: 
  $ git tag -a v0.0.1 -m "Creating first version"
  
* Verify that it all works well
  $ python setup.py install 



.. _scripts-and-binaries:

More on Scripts & Binaries
==========================

.. seealso::

    `entry points`

Any executables, binaries or `script`\ s associated with a package
should be placed in a :file:`bin/` directory in the :term:`repository root`.
Each binary should have its executable bit set (via :command:`chmod
+x`).

It is recommended that they *not* have file extensions.

Scripts must contain a shebang line, and it is strongly recommended that
the shebang line be ``#! /usr/bin/env python`` so that `virtualenv`\ s
are respected.

.. note::

    Package installation will rewrite shebang lines no matter what when
    the package is installed to point to the correct Python installation
    (the one used to perform the installation).

Each binary to install should also appear in the scripts argument in the
package's `setup.py` so that it is installed along with the package.

You can use

    .. code-block:: python

        import os


        BIN_DIR = os.path.join(os.path.dirname(__file__), "bin")

        setup(
            ...
            scripts=[os.path.join("bin", bin) for bin in os.listdir(BIN_DIR)],
        )


to automatically include all scripts in the :file:`bin/` directory.

.. note::

    Do *not* use absolute paths to scripts in the `setup.py`, since
    unfortunately `setuptools` requires them to be relative to the
    `setup.py` / :term:`repository root`.

It is occasionally also useful to split scripts into two categories and
place each category of scripts in its own folder:

* scripts intimately related to "core functionality" of the package
* auxiliary scripts that may be of use alongside the package but whose
  purpose is tangential or for development only

In this case, it is recommended to use :file:`bin/` for the former and
:file:`tools/` for the latter.
