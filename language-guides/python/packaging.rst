=========================
Packaging Python Projects
=========================

.. seealso::

    `The PyPA documentation on `distributions <distribution package>`
    <https://packaging.python.org/en/latest/distributing/#configuring-your-project>`_

.. glossary::
    module
        1) used loosely to mean `source file`
        2) A runtime object, often an instance of `types.ModuleType`,
           and often corresponding to a source file on disk (but not
           necessarily so, runtime modules can be instances of any objects)

    source file
        A file containing Python statements. The typical source file
        extension is ``.py``.

    script
        A source file specifically intended to be executed rather than
        imported or used as library code. Scripts do *not* necessarily
        have file extensions.

            .. seealso::

                `scripts-and-binaries`_

    package
        A directory containing a :file:`__init__.py` along with
        typically other source files, subpackages, and package data
        (non-Python files)

    repository root
        The root of a version-controlled repository.

        It should contain at minimum:
            * a README
            * one (or more) packages
            * a :term:`setup.py`

        And may also contain:
            * a :term:`requirements file`
            * a :doc:`deployment </deployment>` script
            * a `MANIFEST.in
              <https://packaging.python.org/en/latest/distributing/?highlight=manifest#manifest-in>`_
              containing additional package data to include when
              building `distributions <distribution package>` of the
              package
            * development-focused provisioning of a virtual machine or other
              locally-runnable, fully integrated deployment of the package
              along with any needed databases or hard dependencies


Package Structure
=================

For packaging Python projects (new and old), follow the guidelines outlined in
`this blog post
<http://blog.habnab.it/blog/2013/07/21/python-packages-and-you/>`_ with only
slight modification and addition:

* Always use `setuptools` when writing a `setup.py` (mentioned in the
  article as a suitable alternative, but setuptools is now more mature and
  better maintained than it was).
* Avoid ``if __name__ == "__main__"`` blocks in modules in favor of an explicit
  script or a setuptools `entry point
  <https://pythonhosted.org/setuptools/setuptools.html#automatic-script-creation>`_.


.. _requirements.txt:


requirements.txt
================

:file:`requirements.txt` (and other similarly named files) are mechanisms for
specifying *deployment environments* -- i.e., they delineate a *fixed* or
"almost" fixed set of package versions that are known-working for the
associated package.

A requirements file should be *generated by hand* as a package grows
dependencies and is deployed, by adding each dependency to the requirements
file along with the version used at time of deployment.

.. note::

    Avoid using ``pip freeze`` post hoc to generate requirements files.

Installing a requirements file is essentially equivalent to passing each of its
containing options as command line options to `pip`, and can be performed by
running:

    $ pip install -r requirements.txt

.. seealso::

    https://caremad.io/2013/07/setup-vs-requirement/

Common variants of requirements are :file:`test-requirements.txt` to specify
testing dependencies, :file:`doc-requirements.txt` to specify requirements for
building a package's documentation, and :file:`deploy-requirements.txt` for
specifying deployment dependencies. These variants should generally contain a
line with ``-r requirements.txt`` if they need to also include the general
requirements, rather than duplicating them.

.. note::

    In all cases, requirements contain *Python* (and closely related)
    dependencies. A package may have non-Python dependencies that may
    not be installable via ``pip install`` and may require the use of
    the host OS's package manger.


.. _versioning:

Versioning
==========

Mechanisms
----------

Versioning a Python package is functionality that is generally managed
by `setuptools` during installations of `distributions <distribution
package>`. A version is provided to :func:`setuptools.setup` which tells
setuptools what version is being installed (which it uses to decide on
ordering of versions, etc.).

As a separate but important concern, occasionally developers
wish to know "which version of a particular module or package
is currently installed or imported" from within a `REPL
<https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>`_.
This use case makes having the version information easily accessible at
runtime an important consideration.

There are many ways to solve both use cases, the most basic of
which is to duplicate the version information as a parameter to
:func:`setuptools.setup`, and again within a module in the package such
that the version is available at runtime.

A slightly DRYer approach is to import the version from within the
package and to use that when running `setuptools`, but there are a
number of gotchas to this approach, particularly because it conflates
the build and install process with the *installed* state of a package
-- i.e., to import the version from within `setuptools`, the module
containing the version must have *no dependencies, either internal or
external*, since any dependencies will cause potential import issues
when run on a not-yet-installed package.

Also worth noting is that version information is often duplicated in
an *external* place -- inside the version control system. For these
reasons and others, the guild recommendation is to use a package called
`vcversioner`, whose job it is to *expose VCS versions into both places
discussed above such that versions are specified in exactly one place*.

* Add `vcversioner` to the repository's :file:`setup.py` as a *setup*
  dependency (i.e. one needed to run the setup via :code:`setup_requires`, not
  at install time via :code:`install_requires` where `vcversioner` is not
  required). An additional parameter is required to tell `vcversioner` which
  module to generate the version inside of, for which the recommended name is
  :file:`{package}/_version.py`:

  .. code-block:: python

        setup(
            name="exchanges",
            ...
            setup_requires=["vcversioner"],
            vcversioner={"version_module_paths": ["exchanges/_version.py"]},
        )

* Alter :file:`{package}/__init__.py` the `repository root` to expose the
  version at runtime for the installed version of the package by adding
  :samp:`from {package}._version import __version__` to it.

* Create an initial version with or without any concrete contents:

    $ git tag -a v0.1.0 -m "Create a first version"

* Test the installation by attempting to install the package with `pip`:

    $ pip install --user .

An example can be found in many existing GitHub repositories within the
Magnetic organization, including e.g. `Pier <https://github.com/Magnetic/Pier/blob/9ead80600ab89e7c335781d33cc08ede9d079ffd/setup.py#L28-L29>`_

See the `vcversioner` documentation for more details.


Numbering Schemes
-----------------

Separate from the issue of exposing versioning information is a choice of
*which* numbers to use and how to manage them over time.

For reasons of consistency, the general recommendation is to elect to
use `SemVer <http://semver.org/>`_ unless there are significant reasons
for a change.


.. _scripts-and-binaries:

More on Scripts & Binaries
==========================

.. seealso::

    `entry points`

Any executables, binaries or `script`\ s associated with a package
should be placed in a :file:`bin/` directory in the :term:`repository root`.
Each binary should have its executable bit set (via ``chmod +x``).

It is recommended that they *not* have file extensions.

Scripts must contain a shebang line, and it is strongly recommended that
the shebang line be ``#! /usr/bin/env python`` so that `virtualenv`\ s
are respected.

.. note::

    Package installation will rewrite shebang lines no matter what when
    the package is installed to point to the correct Python installation
    (the one used to perform the installation).

Each binary to install should also appear in the scripts argument in the
package's `setup.py` so that it is installed along with the package.

You can use

    .. code-block:: python

        import os


        BIN_DIR = os.path.join(os.path.dirname(__file__), "bin")

        setup(
            ...
            scripts=[os.path.join("bin", bin) for bin in os.listdir(BIN_DIR)],
        )


to automatically include all scripts in the :file:`bin/` directory.

.. note::

    Do *not* use absolute paths to scripts in the `setup.py`, since
    unfortunately `setuptools` requires them to be relative to the
    `setup.py` / :term:`repository root`.

It is occasionally also useful to split scripts into two categories and
place each category of scripts in its own folder:

* scripts intimately related to "core functionality" of the package
* auxiliary scripts that may be of use alongside the package but whose
  purpose is tangential or for development only

In this case, it is recommended to use :file:`bin/` for the former and
:file:`tools/` for the latter.
